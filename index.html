<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>快速排序</title>
 </head>
 <body>
 <h1>快速排序</h1>
	<div id="article_content" class="article_content clearfix">
                                                <div class="article-copyright">
                <span class="creativecommons">
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                    </a>
            <span>版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。 </span>
               <div class="article-source-link2222">
                    本文链接：<a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">https://blog.csdn.net/nrsc272420199/article/details/82587933</a>
                </div>
            </span>
                    </div>
                                                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
                                        <div id="content_views" class="markdown_views">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2 id="原理"><a name="t0"></a>原理:</h2>

<p>   快速排序,说白了就是给基准数据找其正确索引位置的过程. <br>
   如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾. <br>
<img src="https://img-blog.csdn.net/20180910121224126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
   首先从后半部分开始，<strong>如果扫描到的值大于基准数据就让high减1</strong>,<strong><em>如果发现有元素比该基准数据的值小(如上图中18&lt;=tmp)，就将high位置的值赋值给low位置</em></strong> ,结果如下: <br>
<img src="https://img-blog.csdn.net/20180910121350322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
然后开始从前往后扫描,<strong>如果扫描到的值小于基准数据就让low加1</strong>,<strong><em>如果发现有元素大于基准数据的值(如上图46=&gt;tmp)，就再将low位置的值赋值给high位置的值</em></strong>,指针移动并且数据交换后的结果如下: <br>
<img src="https://img-blog.csdn.net/20180910121503615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
然后再开始从后向前扫描,原理同上,发现上图11&lt;=tmp,则将low位置的值赋值给high位置的值,结果如下: <br>
<img src="https://img-blog.csdn.net/20180910121538339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
然后再开始从前往后遍历,直到low=high结束循环,此时low或high的下标就是基准数据23在该数组中的正确索引位置.如下图所示. <br>
<img src="https://img-blog.csdn.net/20180910121618344?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title=""> <br>
  这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的左边,把比基准数小的放在基准数的右边,这样就找到了该数据在数组中的正确位置. <br>
  以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</p>



<h2 id="一些小结论"><a name="t1"></a>一些小结论</h2>

<p>从上面的过程中可以看到:</p>

<p>  ①先从队尾开始向前扫描且当low &lt; high时,如果a[high] &gt; tmp,则high–,但如果a[high] &lt; tmp,则将high的值赋值给low,即arr[low] = a[high],同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了 <br>
  ②同理,当从队首开始向队尾进行扫描时,如果a[low] &lt; tmp,则low++,但如果a[low] &gt; tmp了,则就需要将low位置的值赋值给high位置,即arr[low]  = arr[high],同时将数组扫描方式换为由队尾向队首进行扫描. <br>
  ③不断重复①和②,知道low&gt;=high时(其实是low=high),low或high的位置就是该基准数据在数组中的正确索引位置.</p>



<h2 id="按照上诉理论我写的代码如下"><a name="t2"></a>按照上诉理论我写的代码如下:</h2>



<pre class="prettyprint" name="code"><code class="hljs cs has-numbering" onclick="mdcp.signin(event)" style="position: unset;">package com.nrsc.sort;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> QuickSort {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        <span class="hljs-keyword">int</span>[] arr = { <span class="hljs-number">49</span>, <span class="hljs-number">38</span>, <span class="hljs-number">65</span>, <span class="hljs-number">97</span>, <span class="hljs-number">23</span>, <span class="hljs-number">22</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">22</span> };
        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"排序后:"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) {
            System.<span class="hljs-keyword">out</span>.println(i);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span>(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high) {

        <span class="hljs-keyword">if</span> (low &lt; high) {
            <span class="hljs-comment">// 找寻基准数据的正确索引</span>
            <span class="hljs-keyword">int</span> index = getIndex(arr, low, high);

            <span class="hljs-comment">// 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序</span>
            quickSort(arr, <span class="hljs-number">0</span>, index - <span class="hljs-number">1</span>);
            quickSort(arr, index + <span class="hljs-number">1</span>, high);
        }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span>(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high) {
        <span class="hljs-comment">// 基准数据</span>
        <span class="hljs-keyword">int</span> tmp = arr[low];
        <span class="hljs-keyword">while</span> (low &lt; high) {
            <span class="hljs-comment">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span>
            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp) {
                high--;
            }
            <span class="hljs-comment">// 如果队尾元素小于tmp了,需要将其赋值给low</span>
            arr[low] = arr[high];
            <span class="hljs-comment">// 当队首元素小于等于tmp时,向前挪动low指针</span>
            <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= tmp) {
                low++;
            }
            <span class="hljs-comment">// 当队首元素大于tmp时,需要将其赋值给high</span>
            arr[high] = arr[low];

        }
        <span class="hljs-comment">// 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置</span>
        <span class="hljs-comment">// 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]</span>
        arr[low] = tmp;
        <span class="hljs-keyword">return</span> low; <span class="hljs-comment">// 返回tmp的正确位置</span>
    }
}
<div class="hljs-button signin" data-title="登录后复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li></ul></pre>                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet">
                    </div>
 </body>
</html>
